#calls the neccesary imports
import pygame
import os

#calls the class, def and variables from the other files
from pygame.transform import flip
from settings import player_anim
from settings import Sound
from support import import_folder 
from support import import_sounds
from particle import *
from menu import *




#class used for all things related to the player behavior
class Player(pygame.sprite.Sprite):
    def __init__(self,pos,Screen) -> None:
        #creates the rect for the image, hitbox, variables, vectors, objects, starts playing the background music and imports all
        #the necessary images from the necessary folders with the required sound effects
        super().__init__()
        self.import_assets()
        self.frame_index = 0 
        self.animation_speed = 0.15
        self.image =  player_anim['idle-01'][self.frame_index]
        self.rect = self.image.get_rect(midtop = pos)
        self.rect.width = 32
        self.rect.height = 64       
        self.direction = pygame.math.Vector2(0,0)
        self.speed = 6
        self.gravity_force = 1.3
        self.jump_force = -18
        self.status = 'idle'
        self.facing_right = True
        self.on_ground = False
        self.on_hung = False
        self.hung_time = 0
        self.on_ceiling = False
        self.on_left = False
        self.on_right = False
        self.on_crouch = False
        self.particles = Particle(Screen)
        self.Screen = Screen
        self.lives = 3
        self.hit_timeout = 0
        self.die = False
        Sound['sounds'][0].play(-1)

    #puts all the music and images neccesary in the appropiate dictonarie
    def import_assets(self):
        character_path = 'assets/'

        #Runs this same piece of code for each key on the correct dictionary
        for animation in player_anim.keys():
            #combines the character path with the key path to get the path to the correct folder with the neccesary images
            full_path = character_path + animation
            #adds the memory addreses from the required files into the correct key of the dictionary
            player_anim[animation] = import_folder(full_path)

        #Makes the exact same thing as the previous for loup just with sounds instead of with images
        for sound in list(Sound):
            full_path = character_path + sound
            Sound[sound] = import_sounds(full_path)
        
        #code that runs every frame to make all the actions neccesary for the player to function correctly
    def update(self):
        #timeout time after a hit to not get a hit every frame 
        self.hit_timeout -= 1
        #runs the code in charge of cycle betwen animations
        self.anim() 
        #draws the hitbox of the players when h is pressed
        keys = pygame.key.get_pressed()
        if keys[pygame.K_h]:
            pygame.draw.rect(self.Screen, (123,123,123), self.rect,1)
        #gets all the inputs of the user keyboard
        self.get_input()
        #makes the lateral movement of the player in relation on the direction of the player
        self.rect.x += self.direction.x * self.speed  
        #if the variable die is true makes the background grey
        if self.die:
            pygame.draw.rect(self.Screen, (123,123,123), pygame.Rect(0, 0, 10000, 100000))


    #makes the vertical direction equal to the jump force generated by the player
    def jump(self):
        self.direction.y = self.jump_force
    
    #makes the direction to be changed by a force all the time to generate a increasing 
    #downward force  and it applies this direction to the player
    def gravity(self):
        self.direction.y += self.gravity_force
        self.rect.y += self.direction.y
        
    def get_input(self):
        #create a variable for keys pressed as is used lots of times
        keys = pygame.key.get_pressed()
        #if you press the space key and have clearance for it
        if keys[pygame.K_SPACE] and self.on_hung:
            #runs the jump func
            self.jump()
            #plays the jump sound
            Sound['sounds'][1].play()
            #it makes crouching to be false
            self.on_crouch = False
        #makes so that you can control the jump height
        elif keys[pygame.K_SPACE]:
            pass
        #if you press the left shift key it will make the crouch variable to turn true
        elif keys[pygame.K_LSHIFT]:
            self.on_crouch = True
        #if you are not pressing any key then you are not crouching and it makes you start falling to be able to start falling
        else:
            self.on_crouch = False
            if self.direction.y < 0:
                self.direction.y = 0
        #when pressing the right arrow or d key set the vector x to 1 and the facing to right to flip the image correctly
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.direction.x = 1
            self.facing_right = True
        #when pressing the left arrow or a key set thevector x to -1 and the facing to left to flip the image correctly
        elif keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.direction.x = -1
            self.facing_right = False
        #if your not pressing either left or right make the direction 0 so that you stay in place
        else:
            self.direction.x = 0 
        
    #def that controls the cycling of animations
    def anim(self):
        #runs the get status def to get the current status depending on what the player is currently doing
        self.get_status()
        #update and draw the active particles and delete then if neccessary
        self.particles.emit()
        #get in the animations the key of the dictionary of the current status to cycle between the animation
        animation =  player_anim[self.status]
        #add to the frame index an amount depending of the speed of that animaton to cycle to the next one
        self.frame_index += self.animation_speed
        #if the next frame of the frame index doesnt exist because is bigger than the amount of frames that 
        #that animation haves is reseted to 0
        if self.frame_index > len(animation):
            self.frame_index = 0
        #the current frame for the animation is the rounded number of the index
        image = animation[int(self.frame_index)]
        #if the image is facing the right way you copy it to the main image from the temp one
        if self.facing_right:
            self.image = image
        #if the image is facing the wrong way you flip it and after you copy it to the main image from the temp one
        else:
            flipped_image = pygame.transform.flip(image,True,False)
            self.image = flipped_image
        #you set the correct scale for the picture
        self.image = pygame.transform.scale(self.image, (64,64))

        #depending of what you are using the player will use a different coordinate for the collision so if you are on
        #the ground you will use the bottom coordinate on collision and when you hit the ceiling you will use the top coordinate
        if self.on_ground:
            self.rect = self.image.get_rect(midbottom = self.rect.midbottom)
        elif self.on_ceiling:
            self.rect = self.image.get_rect(midtop = self.rect.midtop)
        else:
            self.rect = self.image.get_rect(center = self.rect.center)
        
    #this def is used to get the status to set the current anim to play
    def get_status(self):
        #if you are crouching and not moving you will have the crouch state 
        if self.on_crouch and self.direction.y == 0:
            self.status = 'crouch'

        #if you have a downward direction that is bigger than the resting gravity force you will have the falling state
        if self.direction.y >= self.gravity_force*2 :
            self.status = 'fall'
        #if you have a upward direction that is smaller than the resting gravity force you will have the jumping state
        elif self.direction.y <= - self.gravity_force*2 : 
            self.status = 'jump'
        #if you dont have any vertical movement
        else:
            #if you are moving and touching the ground you get the running status and create some particles on your feet
            if self.direction.x != 0 and self.on_ground:
                self.status = 'run'
                for i in range(10):
                    self.particles.add_particles(self.rect.x + 32,self.rect.y + 64)
            #if you didnt get any of the other status you get the idle status
            else:
                if self.on_crouch == False:
                    self.status = 'idle-01'
    #if the timeout ended you lose one live, play the hit sound and restart the timeout timer if you get 0 
    #lives your dead so the variable dead goes true
    def hit(self):
        if self.hit_timeout < 0:
            self.lives -= 1
            Sound['sounds'][3].play()
            self.hit_timeout = 60
            if self.lives == 0:
                self.die = True








